# RFC: MVCC for Tonbo — Design, Legacy Overview, Risks, and Recommendations

- Status: Draft
- Authors: Tonbo team
- Created: 2025-08-24
- Area: Concurrency control, in-memory + on-disk storage, WAL

## Summary

This RFC proposes a practical Multi-Version Concurrency Control (MVCC) design for the current Tonbo codebase (hybrid mutable + immutable design with typed and dynamic modes). It:

- Summarizes the legacy Tonbo MVCC implementation and its guarantees.
- Highlights risks and gaps observed in the legacy design.
- Proposes an MVCC model aligned with the new in-memory layout and compaction approach.
- Outlines migration, testing, and open questions.

Goals:

- Snapshot isolation for readers with read-your-own-writes in transactions.
- Simple, scalable write path with commit timestamps and last-writer-wins semantics per key at a given read timestamp.
- MVCC-aware compaction and optional garbage collection of old versions.

Non-Goals (initial rollout):

- Full serializability or predicate locking (phantoms allowed under SI).
- Distributed transactions or cross-instance coordination.
- Complex secondary indexes (primary key only for now).

---

## Legacy MVCC (for context)

Path: `/Users/gwo/Idea/seren`

High-level model:

- Optimistic snapshot isolation with commit timestamps.
- Per-key multi-versions stored in-memory and on-disk, with tombstones for deletes.
- Transactions buffer local writes, lock keys at commit, check conflicts against snapshot, then commit with a single `commit_ts`.

Key mechanics (selected):

- Timestamp encoding: `Timestamp(u32)`, logical, monotonic per-DB. Ordering via `TsRef` sorts `(key ASC, ts DESC)`.
- Mutable store: `SkipMap<Ts<Key>, Option<R>>` for all versions; range scans bound by `(key, read_ts)`; conflict check detects any commit with `ts > snapshot_ts` for the same key.
- Immutable (in-RAM): `BTreeMap<Ts<Key>, row_idx>` index into an Arrow batch; scans and gets bounded by `read_ts`.
- On-disk SST: Parquet row filters enforce `ts <= read_ts` and lexicographic primary key range; merge over levels.
- WAL: frames `Full/First/Middle/Last` across a txn; recovery replays frames and reassigns new increasing timestamps while preserving order.
- Transactions: local `BTreeMap<Key, Option<R>>`; per-key locking on commit; read-your-own-writes via a merged in-memory stream.

Correctness properties:

- Snapshot isolation (SI): readers see only versions with `commit_ts <= read_ts`.
- Read-your-own-writes: a transaction’s local buffer is visible to its own reads.
- Atomic multi-key commit: a txn’s mutations become visible at a single logical commit timestamp.

---

## Legacy Risks and Gaps

- Timestamp width: `u32` risks wraparound under sustained throughput or long uptime; difficult to audit once deployed.
- MVCC GC: No reader watermark or version reclamation; old versions and tombstones accumulate indefinitely.
- Recovery timestamps: Recovered commits are assigned new logical timestamps (not original ts); acceptable for SI but must be documented.
- Tombstone visibility: Range scans surface tombstones as explicit `None`; many APIs prefer filtered semantics by default.
- SI limits: Write skew and phantoms are possible; isolation level needs explicit documentation.
- Conflict scope: Conflicts are only per-key; cross-key invariants are not enforced (expected under SI but should be called out).
- Operational: No explicit reader registry; compaction lacks MVCC-aware pruning.

---

## MVCC Design for Current Tonbo

This design adapts MVCC to the new in-memory layout that separates write absorption (mutable, unsorted) from scan efficiency (immutable segments), unifying typed and dynamic modes.

### Assumptions and Scope

- Primary keys only (single or composite). Typed mode uses `R::Key`; dynamic uses `KeyDyn` (including `Tuple`).
- Single-node instance; durability via WAL (see RFC 0002). Background compaction produces immutable segments.
- Isolation level: snapshot isolation (SI). Phantoms are allowed; predicate locking is out of scope.

### Timestamps and Read Views

- Timestamp type: `Timestamp(u64)` monotonic, assigned at commit. Replace any `u32` uses as part of migration.
- Read view: `ReadView { read_ts: u64 }` acquired at the start of a snapshot/transaction.
- Visibility rule: a version is visible if `begin_ts <= read_ts && end_ts > read_ts && !tombstone`.

### Write Path (MVP)

- Autocommit mode (no explicit transaction): each ingest (typed row or dynamic batch) receives a fresh `commit_ts` from a monotonic sequence.
- Optional transactions (follow-up): buffer mutations; lock keys at commit; if no conflicting writes after snapshot, assign a single `commit_ts` to the batch and publish.

### Mutable Structures

- Current shape:
  - Typed: append open rows; track last-writer index `BTreeMap<Key, WriteLoc>`.
  - Dynamic: attach `Arc<RecordBatch>` chunks; build per-chunk sorted `(key, row_idx)` for scans; last-writer index by key.
- MVCC augmentation:
  - Version metadata: annotate each ingested unit (single row or batch) with `commit_ts` and `tombstone`.
  - Per-key latest map: keep `BTreeMap<Key, (latest_ts, latest_is_tombstone)>` to answer “present at read_ts?” quickly.
  - Optional per-key version list (for full MVCC row reads pre-compaction): maintain a compact vector of `(commit_ts, loc)` per key, capped by policy. Otherwise, defer row materialization to immutables.
  - Dynamic batches: store a batch-level `commit_ts` (all rows share the same ts); record row tombstones via a side bitmap or a delete list.

### Immutable Segments (In-Memory and On-Disk)

- Add system columns to immutable representations:
  - `_begin_ts: u64`, `_end_ts: u64` (exclusive), `_tombstone: bool`.
  - Typed immutables (`ImmutableArrays<R>`, planned return): extend builders to write MVCC columns as side arrays; maintain PK index as today once the typed path is reintroduced.
  - Dynamic immutables (`RecordBatch`): extend schema with MVCC columns (Arrow), and fill during sealing/compaction.
- Indexing:
  - Keep PK-only BTree index for scans; apply MVCC filter using the columns per row.
  - Store per-chunk min/max of `_begin_ts/_end_ts` to skip quickly at read_ts.

### Scans and Queries

- Mutable key-only scans: add `scan_mutable_ranges_mvcc(read_ts)` that yields keys whose latest visible version exists at `<= read_ts` and is not tombstoned, using the per-key latest map.
- Immutable scans: return rows/keys with `_begin_ts <= read_ts < _end_ts && !_tombstone`; if only keys are needed, return PKs after filtering.
- Expression to range extraction remains unchanged; MVCC evaluates post-pruning.

### Compaction and Garbage Collection

- Reader registry: track active read views to compute `gc_watermark = min(active_read_ts)`.
- MVCC-aware compaction:
  - Merge versions per key; set `_end_ts` to the next higher `_begin_ts` (or `INF` for latest).
  - Drop versions that are fully shadowed at `gc_watermark` (i.e., `_end_ts <= gc_watermark`).
  - Optionally cap retained history per key or retain by TTL.

### WAL Integration

- Frame additions (compatible with RFC 0002):
  - `TxnBegin { provisional_id }` (optional for explicit transactions)
  - `Append { provisional_id, rows|batch }`
  - `Commit { provisional_id, commit_ts }`
- Recovery:
  - Rebuild mutable state using `commit_ts` from log; ignore uncommitted provisionals.
  - Persist last assigned `commit_ts` in manifest (already supported in legacy).

### Concurrency and Conflicts

- Per-key locks on commit when transactions are enabled; autocommit mode uses atomic sequence without contention beyond WAL.
- Conflict detection (transactional mode): if any committed version for a key has `begin_ts > snapshot_ts`, abort with `WriteConflict(key)`.

---

## Recommendations (Implementation Plan)

1) Core timestamp and views
- Introduce `Timestamp(u64)` and a monotonic counter; add `DB::begin_read() -> ReadView`.

2) Mutable MVCC metadata
- Typed: store `commit_ts` and `tombstone` per appended row; maintain `BTreeMap<Key, (latest_ts, is_tombstone)>`.
- Dynamic: attach `commit_ts` per batch; record tombstones; update latest map by key.

3) Immutable MVCC columns
- Extend typed immutable builders to add `_begin_ts`, `_end_ts`, `_tombstone` arrays.
- Extend dynamic segment schemas with the same columns; wire sealing to populate them.

4) Scans and APIs
- Add `scan_mutable_ranges_mvcc(read_ts)` for key-only MVCC scans.
- Add immutable scan filters for MVCC columns; expose helpers to return only keys.

5) Compaction + GC
- Add reader registry to compute `gc_watermark`.
- Implement MVCC-aware merging and pruning under watermark.

6) Transactions (optional, phase 2)
- Local mutation buffer, per-key locks, conflict checks, single `commit_ts` assignment.
- WAL support for begin/append/commit frames.

7) Documentation
- Clearly document isolation level (SI), tombstone semantics, and time-travel constraints.

---

## Migration and Compatibility

- Backward compatibility: keep existing key-only scan APIs; add MVCC variants. Existing usage can continue without transactions (autocommit mode).
- Storage: new immutables include MVCC columns; readers ignoring them can still operate on PK-only scans if desired.
- WAL and manifest: persist and restore `commit_ts` counter; no need to preserve historical ts identities for SI.

---

## Testing Strategy

- Unit:
  - Visibility: `_begin_ts/_end_ts/_tombstone` evaluation across edge cases (inclusive/exclusive bounds).
  - Typed and dynamic paths share the same rules; include composite key cases.
- Integration:
  - Reads at varying `read_ts` across mutable/immutable/SST boundaries.
  - Write conflicts with concurrent txns; read-your-own-writes.
  - Recovery: partial frames, re-assignment of `commit_ts`, visibility correctness.
  - Compaction: pruning below `gc_watermark` without breaking snapshots.

---

## Open Questions

- Mutable row materialization pre-compaction: gather-by-offset APIs and cost trade-offs.
- Partial updates and column-level tombstones (future work vs. row-level only now).
- Optional serializable mode via key-range locking or predicate index (out of scope for this RFC).
