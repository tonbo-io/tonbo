use std::{collections::HashMap, sync::Arc};

use fusio::{
    DynFs,
    disk::LocalFs,
    executor::{Executor, Timer, tokio::TokioExecutor},
    fs::FsCas as FusioCas,
    mem::fs::InMemoryFs,
    path::{Path, PathPart},
};
use thiserror::Error;

use super::{DB, Mode};
use crate::{
    extractor::KeyExtractError,
    manifest::{ManifestError, TableId, TonboManifest, init_fs_manifest},
    wal::{
        WalConfig,
        state::{FsWalStateStore, WalStateStore},
    },
};

/// Builder-style configuration surface for constructing a [`DB`] instance.
///
/// The builder enforces that callers explicitly select a storage backend
/// (in-memory, local disk, or object storage) before the database can be
/// materialised. Additional wiring such as WAL configuration hooks and the
/// manifest bootstrap will be layered on top of this scaffolding in subsequent
/// steps.
pub struct DbBuilder<M>
where
    M: Mode,
{
    mode_config: M::Config,
    storage: Option<StorageBackendSpec>,
    wal_tuning: Option<Box<dyn FnMut(&mut WalConfig) + Send + 'static>>,
}

impl<M> DbBuilder<M>
where
    M: Mode,
{
    pub(super) fn new(mode_config: M::Config) -> Self {
        Self {
            mode_config,
            storage: None,
            wal_tuning: None,
        }
    }

    /// Select the in-memory storage backend, labelling the namespace with the
    /// provided identifier.
    #[must_use]
    pub fn in_memory(mut self, label: impl Into<String>) -> Self {
        self.set_storage(StorageBackendSpec::InMemory {
            label: label.into(),
        });
        self
    }

    /// Select a local filesystem backend rooted at `root`.
    #[must_use]
    pub fn on_disk(mut self, root: impl Into<String>) -> Self {
        self.set_storage(StorageBackendSpec::Disk { root: root.into() });
        self
    }

    /// Select an object-store backend using the provided configuration closure.
    #[must_use]
    pub fn on_object_store<F>(mut self, configure: F) -> Self
    where
        F: FnOnce(&mut ObjectStoreBuilder),
    {
        let mut builder = ObjectStoreBuilder::default();
        configure(&mut builder);
        self.set_storage(StorageBackendSpec::ObjectStore(builder.finish()));
        self
    }

    /// Allow advanced callers to tweak the autogenerated WAL configuration.
    #[must_use]
    pub fn configure_wal<F>(mut self, configure: F) -> Self
    where
        F: FnMut(&mut WalConfig) + Send + 'static,
    {
        self.wal_tuning = Some(Box::new(configure));
        self
    }

    fn set_storage(&mut self, spec: StorageBackendSpec) {
        if self.storage.is_some() {
            panic!("storage backend already selected");
        }
        self.storage = Some(spec);
    }

    /// Materialise a [`DB`] using the accumulated builder state.
    pub fn build(self) -> Result<DB<M, TokioExecutor>, DbBuildError> {
        let executor = Arc::new(TokioExecutor::default());
        self.build_with_executor(executor)
    }

    /// Materialise a [`DB`] using a caller-provided executor implementation.
    pub fn build_with_executor<E>(self, executor: Arc<E>) -> Result<DB<M, E>, DbBuildError>
    where
        E: Executor + Timer + Send + Sync + 'static,
    {
        self.build_internal(executor)
    }

    fn build_internal<E>(self, executor: Arc<E>) -> Result<DB<M, E>, DbBuildError>
    where
        M: Mode,
        E: Executor + Timer + Send + Sync + 'static,
    {
        let storage_spec = self.storage.ok_or(DbBuildError::MissingStorage)?;
        let layout = StorageLayout::new(storage_spec)?;
        let manifest_init = ManifestBootstrap::new(&layout);

        let (mode, mem) = M::build(self.mode_config).map_err(DbBuildError::Mode)?;
        let (manifest, manifest_table) = manifest_init.init_manifest()?;

        let mut wal_cfg = WalConfig::default();
        layout.apply_wal_defaults(&mut wal_cfg)?;
        if let Some(mut apply) = self.wal_tuning {
            apply(&mut wal_cfg);
        }

        Ok(DB::from_components(
            mode,
            mem,
            manifest,
            manifest_table,
            Some(wal_cfg),
            executor,
        ))
    }
}

/// Error returned when building a [`DB`] through [`DbBuilder`].
#[derive(Debug, Error)]
pub enum DbBuildError {
    /// No storage backend was selected prior to calling `build`.
    #[error("storage backend not selected")]
    MissingStorage,
    /// The provided storage root could not be parsed.
    #[error("invalid storage path `{path}`: {reason}")]
    InvalidPath {
        /// Path string that failed validation.
        path: String,
        /// Human-readable reason describing the failure.
        reason: String,
    },
    /// Object-store backends are not wired yet.
    #[error("object-store backend support not implemented")]
    UnsupportedObjectStore,
    /// Mode initialisation failed while building the DB.
    #[error(transparent)]
    Mode(#[from] KeyExtractError),
    /// Manifest initialisation failed while building the DB.
    #[error(transparent)]
    Manifest(#[from] ManifestError),
}

#[derive(Debug, Clone)]
pub(crate) enum StorageBackendSpec {
    InMemory { label: String },
    Disk { root: String },
    ObjectStore(ObjectStoreSpec),
}

/// Structured object-store specification captured by `DbBuilder`.
#[derive(Debug, Default, Clone)]
pub(crate) struct ObjectStoreSpec {
    pub(crate) provider: Option<String>,
    pub(crate) endpoint: Option<String>,
    pub(crate) bucket: Option<String>,
    pub(crate) root: Option<String>,
    pub(crate) access_key: Option<String>,
    pub(crate) secret_key: Option<String>,
    pub(crate) extra: HashMap<String, String>,
}

/// Mutable builder used to capture object-store options.
#[derive(Debug, Default)]
pub struct ObjectStoreBuilder {
    spec: ObjectStoreSpec,
}

impl ObjectStoreBuilder {
    /// Set the storage provider identifier (e.g. `"s3"`).
    pub fn provider(&mut self, provider: impl Into<String>) -> &mut Self {
        self.spec.provider = Some(provider.into());
        self
    }

    /// Set the endpoint URL for the object store backend.
    pub fn endpoint(&mut self, endpoint: impl Into<String>) -> &mut Self {
        self.spec.endpoint = Some(endpoint.into());
        self
    }

    /// Set the bucket/container name.
    pub fn bucket(&mut self, bucket: impl Into<String>) -> &mut Self {
        self.spec.bucket = Some(bucket.into());
        self
    }

    /// Set the logical root/prefix under which Tonbo will operate.
    pub fn root(&mut self, root: impl Into<String>) -> &mut Self {
        self.spec.root = Some(root.into());
        self
    }

    /// Set the access key used for authentication.
    pub fn access_key(&mut self, access_key: impl Into<String>) -> &mut Self {
        self.spec.access_key = Some(access_key.into());
        self
    }

    /// Set the secret key used for authentication.
    pub fn secret_key(&mut self, secret_key: impl Into<String>) -> &mut Self {
        self.spec.secret_key = Some(secret_key.into());
        self
    }

    /// Attach an arbitrary key/value option.
    pub fn option(&mut self, key: impl Into<String>, value: impl Into<String>) -> &mut Self {
        self.spec.extra.insert(key.into(), value.into());
        self
    }

    fn finish(self) -> ObjectStoreSpec {
        self.spec
    }
}

#[derive(Clone)]
struct StorageBackend {
    dyn_fs: Arc<dyn DynFs>,
    cas: Option<Arc<dyn FusioCas>>,
    root: Path,
    kind: StorageBackendKind,
}

#[derive(Clone)]
#[allow(dead_code)]
enum StorageBackendKind {
    InMemory { fs: Arc<InMemoryFs> },
    Disk { fs: Arc<LocalFs> },
    ObjectStore(ObjectStoreSpec),
}

#[derive(Clone)]
struct StorageRoute {
    fs: Arc<dyn DynFs>,
    path: Path,
    cas: Option<Arc<dyn FusioCas>>,
}

struct StorageLayout {
    backend: StorageBackend,
}

impl StorageLayout {
    fn new(spec: StorageBackendSpec) -> Result<Self, DbBuildError> {
        let backend = StorageBackend::from_spec(spec)?;
        Ok(Self { backend })
    }

    fn backend(&self) -> &StorageBackend {
        &self.backend
    }

    fn wal_route(&self) -> Result<StorageRoute, DbBuildError> {
        self.backend.route(StorageClass::Wal)
    }

    fn apply_wal_defaults(&self, cfg: &mut WalConfig) -> Result<(), DbBuildError> {
        let route = self.wal_route()?;
        cfg.dir = route.path.clone();
        cfg.segment_backend = Arc::clone(&route.fs);
        cfg.state_store = route
            .cas
            .map(|cas| Arc::new(FsWalStateStore::new(cas)) as Arc<dyn WalStateStore>);
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
enum StorageClass {
    Wal,
}

impl StorageClass {
    fn components(self) -> &'static [&'static str] {
        match self {
            StorageClass::Wal => &["wal"],
        }
    }
}

impl StorageBackend {
    fn from_spec(spec: StorageBackendSpec) -> Result<Self, DbBuildError> {
        match spec {
            StorageBackendSpec::InMemory { label } => {
                if label.is_empty() {
                    return Err(DbBuildError::InvalidPath {
                        path: label,
                        reason: "label cannot be empty".into(),
                    });
                }
                let raw_fs = Arc::new(InMemoryFs::new());
                let dyn_fs: Arc<dyn DynFs> = raw_fs.clone();
                let cas_fs: Arc<dyn FusioCas> = raw_fs.clone();
                let root = Path::parse(&label).map_err(|err| DbBuildError::InvalidPath {
                    path: label,
                    reason: err.to_string(),
                })?;
                Ok(Self {
                    dyn_fs,
                    cas: Some(cas_fs),
                    root,
                    kind: StorageBackendKind::InMemory { fs: raw_fs },
                })
            }
            StorageBackendSpec::Disk { root } => {
                if root.is_empty() {
                    return Err(DbBuildError::InvalidPath {
                        path: root,
                        reason: "root cannot be empty".into(),
                    });
                }
                let raw_fs = Arc::new(LocalFs {});
                let dyn_fs: Arc<dyn DynFs> = raw_fs.clone();
                let cas_fs: Arc<dyn FusioCas> = raw_fs.clone();
                let root_path =
                    Path::from_filesystem_path(&root).map_err(|err| DbBuildError::InvalidPath {
                        path: root,
                        reason: err.to_string(),
                    })?;
                Ok(Self {
                    dyn_fs,
                    cas: Some(cas_fs),
                    root: root_path,
                    kind: StorageBackendKind::Disk { fs: raw_fs },
                })
            }
            StorageBackendSpec::ObjectStore(spec) => build_object_store_backend(spec),
        }
    }

    fn route(&self, class: StorageClass) -> Result<StorageRoute, DbBuildError> {
        let mut current = self.root.clone();
        for part in class.components() {
            let parsed = PathPart::parse(part).map_err(|err| DbBuildError::InvalidPath {
                path: part.to_string(),
                reason: err.to_string(),
            })?;
            current = current.child(parsed);
        }
        Ok(StorageRoute {
            fs: Arc::clone(&self.dyn_fs),
            path: current,
            cas: self.cas.clone(),
        })
    }

    fn kind(&self) -> &StorageBackendKind {
        &self.kind
    }

    fn root(&self) -> &Path {
        &self.root
    }
}

fn build_object_store_backend(_spec: ObjectStoreSpec) -> Result<StorageBackend, DbBuildError> {
    Err(DbBuildError::UnsupportedObjectStore)
}

struct ManifestBootstrap<'a> {
    layout: &'a StorageLayout,
}

impl<'a> ManifestBootstrap<'a> {
    fn new(layout: &'a StorageLayout) -> Self {
        Self { layout }
    }

    fn init_manifest(&self) -> Result<(TonboManifest, TableId), DbBuildError> {
        let backend = self.layout.backend();
        match backend.kind() {
            StorageBackendKind::InMemory { fs } => {
                init_fs_manifest(Arc::as_ref(fs).clone(), backend.root(), 0)
                    .map_err(DbBuildError::Manifest)
            }
            StorageBackendKind::Disk { fs } => {
                init_fs_manifest(Arc::as_ref(fs).clone(), backend.root(), 0)
                    .map_err(DbBuildError::Manifest)
            }
            StorageBackendKind::ObjectStore(_) => Err(DbBuildError::UnsupportedObjectStore),
        }
    }
}
